"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/node/index.ts
var node_exports = {};
__export(node_exports, {
  cdn: () => cdn_exports,
  default: () => node_default,
  util: () => util_exports
});
module.exports = __toCommonJS(node_exports);

// ../../node_modules/.pnpm/tsup@8.0.1_typescript@5.3.3/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/node/_logger.ts
var import_picocolors = __toESM(require("picocolors"), 1);
var log = (tag, message, options) => {
  console.log(
    [
      ((options == null ? void 0 : options.time) ?? false) === true ? import_picocolors.default.dim((/* @__PURE__ */ new Date()).toLocaleTimeString()) : "",
      import_picocolors.default.bold(import_picocolors.default.blue(`[${tag}]`)),
      message
    ].filter((s) => s).join(" ")
  );
};
var info = (tag, message, options) => {
  log(tag, import_picocolors.default.white(message), options);
};
var warn = (tag, message, options) => {
  log(tag, import_picocolors.default.yellow(message), options);
};
var error = (tag, message, options) => {
  log(tag, import_picocolors.default.red(message), options);
};
var createLogger = (tag) => ({
  info: async (message, options) => {
    info(tag, message, options);
  },
  warn: async (message, options) => {
    warn(tag, message, options);
  },
  error: async (message, options) => {
    error(tag, message, options);
  }
});
var logger = createLogger("plugin-monkey");

// src/node/_util.ts
var acornWalk = __toESM(require("acorn-walk"), 1);
var import_node_fs = require("fs");
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_module = require("module");
var import_node_path = __toESM(require("path"), 1);
var import_vite = require("vite");
var get_vite_start_time = () => {
  const n = Reflect.get(globalThis, "__vite_start_time") ?? 0;
  if (typeof n != "number") {
    return 0;
  } else {
    return n;
  }
};
var isFirstBoot = (n = 1e3) => get_vite_start_time() < n;
var GM_keywords = [
  "GM.addElement",
  "GM.addStyle",
  "GM.deleteValue",
  "GM.getResourceUrl",
  "GM.getValue",
  "GM.info",
  "GM.listValues",
  "GM.notification",
  "GM.openInTab",
  "GM.registerMenuCommand",
  "GM.setClipboard",
  "GM.setValue",
  "GM.xmlHttpRequest",
  "GM.cookie",
  "GM_addElement",
  "GM_addStyle",
  "GM_addValueChangeListener",
  "GM_cookie",
  "GM_deleteValue",
  "GM_download",
  "GM_getResourceText",
  "GM_getResourceURL",
  "GM_getTab",
  "GM_getTabs",
  "GM_getValue",
  "GM_info",
  "GM_listValues",
  "GM_log",
  "GM_notification",
  "GM_openInTab",
  "GM_registerMenuCommand",
  "GM_removeValueChangeListener",
  "GM_saveTab",
  "GM_setClipboard",
  "GM_setValue",
  "GM_unregisterMenuCommand",
  "GM_xmlhttpRequest",
  "unsafeWindow",
  "window.close",
  "window.focus",
  "window.onurlchange"
];
var projectPkg = (() => {
  var _a, _b, _c, _d, _e;
  let rawTarget = {};
  try {
    rawTarget = JSON.parse(
      (0, import_node_fs.readFileSync)(import_node_path.default.resolve(process.cwd(), "package.json"), "utf-8")
    );
  } catch {
    rawTarget = {};
  }
  const target = {
    name: "monkey",
    version: "1.0.0"
  };
  Object.entries(rawTarget).forEach(([k, v]) => {
    if (typeof v == "string") {
      Reflect.set(target, k, v);
    }
  });
  if (rawTarget.author instanceof Object && typeof ((_a = rawTarget.author) == null ? void 0 : _a.name) == "string") {
    target.author = (_b = rawTarget.author) == null ? void 0 : _b.name;
  }
  if (rawTarget.bugs instanceof Object && typeof ((_c = rawTarget.bugs) == null ? void 0 : _c.url) == "string") {
    target.bugs = (_d = rawTarget.bugs) == null ? void 0 : _d.url;
  }
  if (rawTarget.repository instanceof Object && typeof ((_e = rawTarget.repository) == null ? void 0 : _e.url) == "string") {
    const { url } = rawTarget.repository;
    if (url.startsWith("http")) {
      target.repository = url;
    } else if (url.startsWith("git+http")) {
      target.repository = url.slice(4);
    }
  }
  return target;
})();
var compatResolve = (() => {
  const compatRequire = (0, import_node_module.createRequire)(process.cwd() + "/any_filename.js");
  return (id) => {
    return compatRequire.resolve(id);
  };
})();
var existFile = async (path5) => {
  try {
    return (await import_promises.default.stat(path5)).isFile();
  } catch {
    return false;
  }
};
var resolvePackageJsonFromPath = async (name) => {
  const p = (0, import_vite.normalizePath)(process.cwd()).split("/");
  for (let i = p.length; i > 0; i--) {
    const p2 = `${p.slice(0, i).join("/")}/node_modules/${name}/package.json`;
    if (await existFile(p2)) {
      return p2;
    }
  }
};
var getModuleRealInfo = async (importName) => {
  const importName2 = (0, import_vite.normalizePath)(importName.split("?")[0]);
  const resolveName = (0, import_vite.normalizePath)(compatResolve(importName2)).replace(
    /.*\/node_modules\/[^/]+\//,
    ""
  );
  let version = void 0;
  const nameList = importName2.split("/");
  let pkgName = importName2;
  while (nameList.length > 0) {
    pkgName = nameList.join("/");
    const filePath = await (async () => {
      const p = await resolvePackageJsonFromPath(pkgName);
      if (p) {
        return p;
      }
      try {
        return compatResolve(`${pkgName}/package.json`);
      } catch {
        return void 0;
      }
    })();
    if (filePath === void 0 || !await existFile(filePath)) {
      nameList.pop();
      continue;
    }
    const modulePack = JSON.parse(
      await import_promises.default.readFile(filePath, "utf-8")
    );
    version = modulePack.version;
    break;
  }
  if (version === void 0) {
    logger.warn(
      `not found module ${importName2} version, use ${importName2}@latest`
    );
    pkgName = importName2;
    version = "latest";
  }
  return { version, name: pkgName, resolveName };
};
var miniCode = async (code, type = "js") => {
  return (await (0, import_vite.transformWithEsbuild)(code, "any_name." + type, {
    minify: true,
    sourcemap: false,
    legalComments: "none"
  })).code.trimEnd();
};
var toValidURL = (url) => {
  if (typeof url != "string")
    return;
  try {
    return new URL(url);
  } catch {
  }
};
var moduleExportExpressionWrapper = (expression) => {
  let n = 0;
  let identifier = ``;
  while (expression.includes(identifier)) {
    identifier = `_${(n || ``).toString(16)}`;
    n++;
  }
  return `(()=>{const ${identifier}=${expression};('default' in ${identifier})||(${identifier}.default=${identifier});return ${identifier}})()`;
};
var cyrb53hash = (str = ``, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(36).substring(0, 8);
};
async function* walk(dirPath) {
  const pathnames = (await import_promises.default.readdir(dirPath)).map(
    (s) => import_node_path.default.join(dirPath, s)
  );
  while (pathnames.length > 0) {
    const pathname = pathnames.pop();
    const state = await import_promises.default.lstat(pathname);
    if (state.isFile()) {
      yield pathname;
    } else if (state.isDirectory()) {
      pathnames.push(
        ...(await import_promises.default.readdir(pathname)).map((s) => import_node_path.default.join(pathname, s))
      );
    }
  }
}
var collectGrant = (context, bundleOrCode) => {
  const codes = [];
  if (typeof bundleOrCode == "string") {
    codes.push(bundleOrCode);
  } else if (Array.isArray(bundleOrCode)) {
    codes.push(...bundleOrCode);
  } else {
    Object.values(bundleOrCode).forEach((chunk) => {
      if (chunk.type == "chunk") {
        codes.push(chunk.code);
      }
    });
  }
  const unusedMembers = new Set(GM_keywords.filter((s) => s.includes(`.`)));
  const unusedIdentifiers = new Set(
    GM_keywords.filter((s) => !s.includes(`.`))
  );
  const usedGm = /* @__PURE__ */ new Set();
  for (const code of codes) {
    if (!code.trim())
      continue;
    const ast = context.parse(code);
    acornWalk.simple(
      ast,
      {
        MemberExpression(node) {
          var _a, _b;
          if (unusedMembers.size == 0)
            return;
          const memberName = ((_a = node.object) == null ? void 0 : _a.name) + "." + ((_b = node.property) == null ? void 0 : _b.name);
          for (const unusedName of unusedMembers.values()) {
            if (memberName.endsWith(unusedName)) {
              usedGm.add(unusedName);
              unusedMembers.delete(unusedName);
              break;
            }
          }
        },
        Identifier(node) {
          if (unusedIdentifiers.size == 0)
            return;
          const identifier = node.name;
          if (unusedIdentifiers.has(identifier)) {
            usedGm.add(identifier);
            unusedIdentifiers.delete(identifier);
          }
        }
      },
      { ...acornWalk.base }
    );
    if (unusedMembers.size == 0 && unusedIdentifiers.size == 0) {
      break;
    }
  }
  return usedGm;
};
var getInjectCssCode = async (finalOption, rawBundle) => {
  const cssTexts = [];
  Object.entries(rawBundle).forEach(([k, v]) => {
    if (v.type == "asset" && k.endsWith(".css")) {
      cssTexts.push(v.source.toString());
      delete rawBundle[k];
    }
  });
  const css = cssTexts.join("").trim();
  if (css) {
    return await finalOption.cssSideEffects(` ` + css + ` `);
  }
};

// src/node/cdn.ts
var cdn_exports = {};
__export(cdn_exports, {
  baomitu: () => baomitu,
  bdstatic: () => bdstatic,
  bootcdn: () => bootcdn,
  bytecdntp: () => bytecdntp,
  cdnjs: () => cdnjs,
  elemecdn: () => elemecdn,
  jsdelivr: () => jsdelivr,
  jsdelivrFastly: () => jsdelivrFastly,
  npmmirror: () => npmmirror,
  staticfile: () => staticfile,
  unpkg: () => unpkg,
  zhimg: () => zhimg
});
var jsdelivr = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      if (p) {
        return `https://cdn.jsdelivr.net/npm/${name}@${version}/${p}`;
      } else {
        return `https://cdn.jsdelivr.net/npm/${name}@${version}`;
      }
    }
  ];
};
var jsdelivrFastly = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      if (p) {
        return `https://fastly.jsdelivr.net/npm/${name}@${version}/${p}`;
      } else {
        return `https://fastly.jsdelivr.net/npm/${name}@${version}`;
      }
    }
  ];
};
var unpkg = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      if (p) {
        return `https://unpkg.com/${name}@${version}/${p}`;
      } else {
        return `https://unpkg.com/${name}@${version}`;
      }
    }
  ];
};
var bytecdntp = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://lf9-cdn-tos.bytecdntp.com/cdn/expire-10-y/${name}/${version}/${p}`;
    }
  ];
};
var bootcdn = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://cdn.bootcdn.net/ajax/libs/${name}/${version}/${p}`;
    }
  ];
};
var baomitu = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://lib.baomitu.com/${name}/${version}/${p}`;
    }
  ];
};
var staticfile = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://cdn.staticfile.org/${name}/${version}/${p}`;
    }
  ];
};
var cdnjs = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://cdnjs.cloudflare.com/ajax/libs/${name}/${version}/${p}`;
    }
  ];
};
var zhimg = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://unpkg.zhimg.com/${name}/${version}/${p}`;
    }
  ];
};
var elemecdn = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://npm.elemecdn.com/${name}@${version}/${p}`;
    }
  ];
};
var bdstatic = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      return `https://code.bdstatic.com/npm/${name}@${version}/${p}`;
    }
  ];
};
var npmmirror = (exportVarName = "", pathname = "") => {
  return [
    exportVarName,
    (version, name, _importName = "", resolveName = "") => {
      const p = pathname || resolveName;
      if (p) {
        return `https://registry.npmmirror.com/${name}/${version}/files/${p}`;
      } else {
        return `https://registry.npmmirror.com/${name}/${version}/files`;
      }
    }
  ];
};

// src/node/inject_template.ts
var fn2string = (fn, ...args) => {
  return `;(${fn})(...${JSON.stringify(args, void 0, 2)});`;
};
var htmlText = (
  /* html */
  `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="https://vitejs.dev/logo.svg" />
    <title>Vite</title>
  </head>
  <script type="module" data-source="vite-plugin-monkey">
  __CODE__
  </script>
</html>
`.trimStart()
);
var fcToHtml = (fn, ...args) => {
  return htmlText.replace(
    `__CODE__`,
    `;(${fn})(...${JSON.stringify(args, void 0, 2)});`
  );
};
var serverInjectFn = ({ entrySrc = `` }) => {
  window.GM;
  const key = `__monkeyWindow-` + new URL(entrySrc).origin;
  document[key] = window;
  console.log(`[vite-plugin-monkey] mount monkeyWindow to document`);
  const entryScript = document.createElement("script");
  entryScript.type = "module";
  entryScript.src = entrySrc;
  document.head.insertBefore(entryScript, document.head.firstChild);
  console.log(`[vite-plugin-monkey] mount entry module to document.head`);
};
var mountGmApiFn = (meta) => {
  const key = `__monkeyWindow-` + new URL(meta.url).origin;
  const monkeyWindow = document[key];
  if (!monkeyWindow) {
    console.log(`[vite-plugin-monkey] not found monkeyWindow`);
    return;
  }
  window.unsafeWindow = window;
  console.log(`[vite-plugin-monkey] mount unsafeWindow to unsafeWindow`);
  const mountedApiList = [];
  Object.entries(monkeyWindow).filter(([k]) => k.startsWith("GM")).forEach(([k, fn]) => {
    window[k] = fn;
    mountedApiList.push(k);
  });
  console.log(
    `[vite-plugin-monkey] mount ${mountedApiList.length} GM_api to unsafeWindow`
  );
};
var virtualHtmlTemplate = async (url) => {
  const delay = async (n = 0) => {
    await new Promise((res) => {
      setTimeout(res, n);
    });
  };
  await delay();
  const u = new URL(url, location.origin);
  u.searchParams.set("origin", u.origin);
  if (window == window.parent) {
    location.href = u.href;
    await delay(500);
    window.close();
    return;
  }
  const style = document.createElement("style");
  document.head.append(style);
  style.innerText = /* css */
  `
  .App {
    margin-top: 10vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  .App > .title {
    padding: 4px;
    font-size: 15px;
  }
  .App > a {
    font-size: 32px;
    text-align: center;
  }
`.trim();
  document.body.innerHTML = /* html */
  `
  <div class="App">
    <div class="title"> please click the link below to install userscipt </div>
    <a target="_blank"></a>
  </div>
  `.trim();
  await delay();
  const a = document.querySelector("a");
  a.href = location.href;
  a.text = location.href;
};
var previewTemplate = async (urls) => {
  const delay = async (n = 0) => {
    await new Promise((res) => {
      setTimeout(res, n);
    });
  };
  await delay();
  const style = document.createElement("style");
  document.head.append(style);
  style.innerText = /* css */
  `
  .App {
    margin-top: 10vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  .App > .title {
    padding: 4px;
    font-size: 15px;
  }
  .App > a {
    font-size: 32px;
    text-align: center;
  }
`.trim();
  if (window == window.parent && urls.length == 1) {
    const u = new URL(urls[0], location.origin);
    location.href = u.href;
    await delay(500);
    window.close();
    return;
  } else if (urls.length == 0) {
    document.body.innerHTML = /* html */
    `
    <div class="App">
      <div class="title"> There is no script to install </div>
    </div>
    `.trim();
    return;
  } else {
    document.body.innerHTML = /* html */
    `
    <div class="App">
      <div class="title"> please click the link below to install userscipt </div>
    </div>
    `.trim();
    await delay();
    const div = document.querySelector(`.App`);
    urls.forEach((u) => {
      const a = document.createElement("a");
      if (window != window.parent) {
        a.target = "_blank";
      }
      a.href = u;
      a.textContent = new URL(u, location.origin).href;
      div.append(a);
    });
  }
};

// src/node/option.ts
var resolvedOption = (pluginOption) => {
  var _a, _b;
  const build2 = pluginOption.build ?? {};
  if (build2.minifyCss !== void 0) {
    logger.warn(
      `monkeyConfig.build.minifyCss is deprecated, use viteConfig.build.cssMinify in vite>=4.2.0`,
      { time: false }
    );
  }
  const { externalResource = {} } = build2;
  const externalResource2 = {};
  for (const [k, v] of Object.entries(externalResource)) {
    if (typeof v == "string") {
      externalResource2[k] = {
        resourceName: () => k,
        resourceUrl: () => v
      };
    } else if (typeof v == "function") {
      externalResource2[k] = {
        resourceName: () => k,
        resourceUrl: v
      };
    } else if (v instanceof Array) {
      let resourceUrl2;
      let resourceName2 = () => k;
      const [resourceName, resourceUrl] = v;
      if (typeof resourceName == "string") {
        resourceName2 = (pkg) => resourceName || pkg.importName;
      } else {
        resourceName2 = (pkg) => resourceName(pkg.version, pkg.name, pkg.importName, pkg.resolveName);
      }
      if (typeof resourceUrl == "string") {
        resourceUrl2 = () => resourceUrl;
      } else {
        resourceUrl2 = (pkg) => resourceUrl(pkg.version, pkg.name, pkg.importName, pkg.resolveName);
      }
      externalResource2[k] = {
        resourceName: resourceName2,
        resourceUrl: resourceUrl2
      };
    } else {
      const { resourceUrl, loader, nodeLoader, resourceName } = v;
      let resourceUrl2;
      let resourceName2 = () => k;
      let nodeLoader2 = void 0;
      if (typeof resourceUrl == "string") {
        resourceUrl2 = () => resourceUrl;
      } else {
        resourceUrl2 = resourceUrl;
      }
      if (typeof resourceName == "string") {
        resourceName2 = () => resourceName;
      } else if (typeof resourceName == "function") {
        resourceName2 = resourceName;
      }
      if (typeof nodeLoader == "function") {
        nodeLoader2 = nodeLoader;
      } else if (typeof nodeLoader == "string") {
        nodeLoader2 = () => nodeLoader;
      }
      externalResource2[k] = {
        resourceName: resourceName2,
        resourceUrl: resourceUrl2,
        loader,
        nodeLoader: nodeLoader2
      };
    }
  }
  const server = pluginOption.server ?? {};
  const { prefix } = server;
  let prefix2 = (s) => "server:" + s;
  if (typeof prefix == "function") {
    prefix2 = prefix;
  } else if (typeof prefix == "string") {
    prefix2 = () => prefix;
  } else if (prefix === false) {
    prefix2 = (name2) => name2;
  }
  const externalGlobals2 = (build2 == null ? void 0 : build2.externalGlobals) ?? {};
  const externalGlobals = [];
  if (externalGlobals2 instanceof Array) {
    externalGlobals2.forEach((s) => externalGlobals.push(s));
  } else {
    Object.entries(externalGlobals2).forEach((s) => externalGlobals.push(s));
  }
  let {
    name = {},
    description = {},
    "exclude-match": excludeMatch = [],
    match = [],
    exclude = [],
    include = [],
    antifeature = [],
    require: require2 = [],
    connect = [],
    grant = [],
    webRequest = [],
    $extra = []
  } = pluginOption.userscript ?? {};
  if (typeof name == "string") {
    name = { "": name };
  } else if (!("" in name)) {
    name = { "": projectPkg.name, ...name };
  }
  if (typeof description == "string") {
    description = {
      "": description
    };
  } else if (!("" in description) && projectPkg.description) {
    description = { "": projectPkg.description, ...description };
  }
  if (!(excludeMatch instanceof Array)) {
    excludeMatch = [excludeMatch];
  }
  if (!(match instanceof Array)) {
    match = [match];
  }
  if (!(exclude instanceof Array)) {
    exclude = [exclude];
  }
  if (!(include instanceof Array)) {
    include = [include];
  }
  if (!(antifeature instanceof Array)) {
    antifeature = [antifeature];
  }
  if (!(require2 instanceof Array)) {
    require2 = [require2];
  }
  if (!(connect instanceof Array)) {
    connect = [connect];
  }
  if (!(webRequest instanceof Array)) {
    webRequest = [webRequest];
  }
  const grantSet = /* @__PURE__ */ new Set();
  if (typeof grant == "string") {
    grantSet.add(grant);
  } else if (grant instanceof Array) {
    grant.forEach((s) => grantSet.add(s));
  }
  const extra = [];
  ($extra instanceof Array ? $extra : Object.entries($extra)).forEach(
    ([k, v]) => {
      extra.push([k, ...v instanceof Array ? v : [v]]);
    }
  );
  const {
    icon64,
    icon64URL,
    icon,
    iconURL,
    namespace = `vite-plugin-monkey`,
    version = projectPkg.version,
    author = projectPkg.author ?? "monkey",
    copyright,
    downloadURL,
    defaulticon,
    contributionURL,
    updateURL,
    supportURL = projectPkg.bugs,
    homepageURL = projectPkg.homepage,
    homepage = projectPkg.homepage,
    website,
    license = projectPkg.license,
    incompatible,
    source = projectPkg.repository,
    resource = {},
    noframes = false,
    "run-at": runAt,
    "inject-into": injectInto,
    contributionAmount,
    compatible,
    sandbox,
    unwrap = false
  } = pluginOption.userscript ?? {};
  const { fileName = projectPkg.name + ".user.js" } = build2;
  let { metaFileName } = build2;
  if (typeof metaFileName == "string") {
    const t = metaFileName;
    metaFileName = () => t;
  } else if (metaFileName === true) {
    metaFileName = () => fileName.replace(/\.user\.js$/, ".meta.js");
  } else if (metaFileName === false) {
    metaFileName = void 0;
  }
  const metaFileFc = metaFileName;
  const cssSideEffects = build2.cssSideEffects || (() => {
    return (e) => {
      if (typeof GM_addStyle == "function") {
        GM_addStyle(e);
        return;
      }
      const o = document.createElement("style");
      o.textContent = e;
      document.head.append(o);
    };
  });
  const config = {
    userscript: {
      name,
      namespace,
      version,
      icon64,
      icon64URL,
      icon,
      iconURL,
      author,
      copyright,
      downloadURL,
      defaulticon,
      contributionURL,
      updateURL,
      supportURL,
      homepageURL,
      homepage,
      website,
      license,
      incompatible,
      source,
      resource,
      noframes,
      "run-at": runAt,
      "inject-into": injectInto,
      contributionAmount,
      compatible,
      "exclude-match": excludeMatch.map((s) => String(s)),
      match: match.map((s) => String(s)),
      include: include.map((s) => String(s)),
      exclude: exclude.map((s) => String(s)),
      antifeature,
      require: require2,
      connect,
      description,
      $extra: extra,
      grant: grantSet,
      sandbox,
      unwrap,
      webRequest: webRequest.map((w) => JSON.stringify(w))
    },
    clientAlias: pluginOption.clientAlias ?? "$",
    entry: pluginOption.entry,
    format: {
      align: ((_a = pluginOption.format) == null ? void 0 : _a.align) ?? 2,
      generate: ((_b = pluginOption.format) == null ? void 0 : _b.generate) ?? ((o) => o.userscript)
    },
    server: {
      mountGmApi: server.mountGmApi ?? false,
      open: server.open ?? (process.platform == "win32" || process.platform == "darwin"),
      prefix: prefix2
    },
    build: {
      fileName,
      metaFileName: metaFileFc ? () => metaFileFc(fileName) : void 0,
      autoGrant: build2.autoGrant ?? true,
      externalGlobals,
      externalResource: externalResource2
    },
    collectRequireUrls: [],
    collectResource: {},
    globalsPkg2VarName: {},
    requirePkgList: [],
    systemjs: build2.systemjs ?? jsdelivr()[1],
    cssSideEffects: async (css) => {
      const codeOrFc = await cssSideEffects(css);
      if (typeof codeOrFc == "string") {
        return codeOrFc;
      }
      return miniCode(fn2string(codeOrFc, css), "js");
    }
  };
  return config;
};

// src/node/plugins/server.ts
var import_htmlparser2 = require("htmlparser2");
var import_promises2 = __toESM(require("fs/promises"), 1);
var import_node_path3 = __toESM(require("path"), 1);
var import_vite2 = require("vite");

// src/node/open_browser.ts
var import_cross_spawn = __toESM(require("cross-spawn"), 1);
var import_node_child_process = require("child_process");
var import_node_path2 = __toESM(require("path"), 1);
var import_picocolors2 = __toESM(require("picocolors"), 1);
var OSX_CHROME = "google chrome";
function openBrowser(url, opt, logger2) {
  const browser = typeof opt === "string" ? opt : process.env.BROWSER || "";
  if (browser.toLowerCase().endsWith(".js")) {
    return executeNodeScript(browser, url, logger2);
  } else if (browser.toLowerCase() !== "none") {
    return startBrowserProcess(browser, url);
  }
  return false;
}
function executeNodeScript(scriptPath, url, logger2) {
  const extraArgs = process.argv.slice(2);
  const child = (0, import_cross_spawn.default)(process.execPath, [scriptPath, ...extraArgs, url], {
    stdio: "inherit"
  });
  child.on("close", (code) => {
    if (code !== 0) {
      logger2.error(
        import_picocolors2.default.red(
          `
The script specified as BROWSER environment variable failed.

${import_picocolors2.default.cyan(
            scriptPath
          )} exited with code ${code}.`
        ),
        { time: true }
      );
    }
  });
  return true;
}
function startBrowserProcess(browser, url) {
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin" && (browser === "" || browser === OSX_CHROME);
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      (0, import_node_child_process.execSync)('ps cax | grep "Google Chrome"');
      (0, import_node_child_process.execSync)('osascript openChrome.applescript "' + encodeURI(url) + '"', {
        cwd: import_node_path2.default.dirname(compatResolve("vite/bin/openChrome.applescript")),
        stdio: "ignore"
      });
      return true;
    } catch (err) {
    }
  }
  if (process.platform === "darwin" && browser === "open") {
    browser = void 0;
  }
  try {
    const options = browser ? { app: { name: browser } } : {};
    import("open").then(({ default: open }) => {
      open(url, options).catch(() => {
      });
    });
    return true;
  } catch (err) {
    return false;
  }
}

// src/node/userscript/greasemonkey.ts
var GreaseGrantValueList = [
  "GM.info",
  "GM.deleteValue",
  "GM.getValue",
  "GM.listValues",
  "GM.setValue",
  "GM.getResourceUrl",
  "GM.notification",
  "GM.openInTab",
  "GM.registerMenuCommand",
  "GM.setClipboard",
  "GM.xmlHttpRequest",
  "unsafeWindow"
];

// src/node/userscript/tampermonkey.ts
var TamperGrantValueList = [
  "unsafeWindow",
  "window.close",
  "window.focus",
  "window.onurlchange",
  "GM_addStyle",
  "GM_addElement",
  "GM_deleteValue",
  "GM_listValues",
  "GM_addValueChangeListener",
  "GM_removeValueChangeListener",
  "GM_setValue",
  "GM_getValue",
  "GM_log",
  "GM_getResourceText",
  "GM_getResourceURL",
  "GM_registerMenuCommand",
  "GM_unregisterMenuCommand",
  "GM_openInTab",
  "GM_xmlhttpRequest",
  "GM_download",
  "GM_getTab",
  "GM_saveTab",
  "GM_getTabs",
  "GM_notification",
  "GM_setClipboard",
  "GM_info",
  "GM_cookie",
  "GM_webRequest"
];

// src/node/userscript/violentmonkey.ts
var ViolentGrantValueList = [
  "window.close",
  "window.focus",
  "GM_info",
  "GM_getValue",
  "GM_setValue",
  "GM_deleteValue",
  "GM_listValues",
  "GM_addValueChangeListener",
  "GM_removeValueChangeListener",
  "GM_getResourceText",
  "GM_getResourceURL",
  "GM_addElement",
  "GM_addStyle",
  "GM_openInTab",
  "GM_registerMenuCommand",
  "GM_unregisterMenuCommand",
  "GM_notification",
  "GM_setClipboard",
  "GM_xmlhttpRequest",
  "GM_download",
  "GM.addStyle",
  "GM.addElement",
  "GM.registerMenuCommand",
  "GM.deleteValue",
  "GM.getResourceUrl",
  "GM.getValue",
  "GM.info",
  "GM.listValues",
  "GM.notification",
  "GM.openInTab",
  "GM.setClipboard",
  "GM.setValue",
  "GM.xmlHttpRequest"
];

// src/node/userscript/index.ts
var finalMonkeyOptionToComment = async ({
  userscript,
  format,
  collectRequireUrls,
  collectResource
}, collectGrantSet, mode) => {
  let attrList = [];
  const {
    name,
    namespace,
    version,
    author,
    description,
    license,
    copyright,
    icon,
    iconURL,
    icon64,
    icon64URL,
    defaulticon,
    homepage,
    homepageURL,
    website,
    source,
    supportURL,
    downloadURL,
    updateURL,
    include,
    match,
    exclude,
    require: require2,
    "exclude-match": excludeMatch,
    "inject-into": injectInto,
    "run-at": runAt,
    compatible,
    incompatible,
    antifeature,
    contributionAmount,
    contributionURL,
    connect,
    sandbox,
    resource,
    grant,
    noframes,
    unwrap,
    webRequest,
    $extra
  } = userscript;
  Object.entries({
    namespace,
    version,
    author,
    license,
    copyright,
    icon,
    iconURL,
    icon64,
    icon64URL,
    defaulticon,
    homepage,
    homepageURL,
    website,
    source,
    supportURL,
    downloadURL,
    updateURL,
    "inject-into": injectInto,
    "run-at": runAt,
    compatible,
    incompatible,
    contributionAmount,
    contributionURL,
    sandbox
  }).forEach(([k, v]) => {
    if (typeof v == "string") {
      attrList.push([k, v]);
    }
  });
  Object.entries(name).forEach(([k, v]) => {
    if (k == "") {
      attrList.push(["name", v]);
    } else {
      attrList.push(["name:" + k, v]);
    }
  });
  Object.entries(description).forEach(([k, v]) => {
    if (k == "") {
      attrList.push(["description", v]);
    } else {
      attrList.push(["description:" + k, v]);
    }
  });
  Object.entries({
    include,
    match,
    exclude,
    "exclude-match": excludeMatch
  }).forEach(([k, v]) => {
    v.forEach((v2) => {
      attrList.push([k, v2]);
    });
  });
  [...require2, ...collectRequireUrls].forEach((s) => {
    attrList.push(["require", s]);
  });
  Object.entries({ ...resource, ...collectResource }).forEach(([k, v]) => {
    attrList.push(["resource", k, v]);
  });
  connect.forEach((s) => {
    attrList.push(["connect", s]);
  });
  webRequest.forEach((s) => {
    attrList.push(["webRequest", s]);
  });
  if (grant.has("none")) {
    attrList.push(["grant", "none"]);
  } else if (grant.has("*")) {
    (/* @__PURE__ */ new Set([
      ...GreaseGrantValueList,
      ...ViolentGrantValueList,
      ...TamperGrantValueList
    ])).forEach((s) => {
      attrList.push(["grant", s]);
    });
  } else {
    (/* @__PURE__ */ new Set([...Array.from(collectGrantSet.values()).flat(), ...grant])).forEach(
      (s) => {
        if (!s.trim())
          return;
        attrList.push(["grant", s]);
      }
    );
  }
  antifeature.forEach(({ description: description2, type, tag }) => {
    attrList.push([
      tag ? `antifeature:${tag}` : "antifeature",
      type,
      description2
    ]);
  });
  if (noframes) {
    attrList.push(["noframes"]);
  }
  if (unwrap) {
    attrList.push(["unwrap"]);
  }
  attrList.push(...$extra);
  attrList = defaultSortFormat(attrList);
  let { align = 2 } = format;
  if (align === true) {
    align = 2;
  }
  if (typeof align == "number" && Number.isInteger(align) && align >= 1) {
    const alignN = align;
    const formatKey = (subAttrList) => {
      if (subAttrList.length == 0)
        return;
      const maxLen2 = Math.max(...subAttrList.map((s) => s[1].length));
      subAttrList.forEach((s) => {
        s[1] = s[1].padEnd(alignN + maxLen2);
      });
    };
    formatKey(attrList.filter((s) => s[0] == "resource"));
    formatKey(
      attrList.filter(
        (s) => s[0] == "antifeature" || s[0].startsWith("antifeature:")
      )
    );
    const maxLen = Math.max(...attrList.map((s) => s[0].length));
    attrList.forEach((s) => {
      s[0] = s[0].padEnd(alignN + maxLen);
    });
  } else if (typeof align == "function") {
    attrList = await align(attrList);
  }
  const uString = [
    "==UserScript==",
    ...attrList.map(
      (attr) => "@" + attr.map((v) => {
        return v.endsWith(" ") ? v : v + " ";
      }).join("").trimEnd()
    ),
    "==/UserScript=="
  ].map((s) => "// " + s).join("\n");
  return format.generate({ userscript: uString, mode });
};
var stringSort = (a, b) => {
  const minLen = Math.min(a.length, b.length);
  for (let i = 0; i < minLen; i++) {
    if (a[i] > b[i]) {
      return 1;
    } else if (a[i] < b[i]) {
      return -1;
    }
  }
  if (a.length > b.length) {
    return 1;
  } else if (a.length < b.length) {
    return -1;
  }
  return 0;
};
var defaultSortFormat = (p0) => {
  const filter = (predicate) => {
    const notMatchList = [];
    const matchList = [];
    p0.forEach((value, index) => {
      if (!predicate(value, index)) {
        notMatchList.push(value);
      } else {
        matchList.push(value);
      }
    });
    p0 = notMatchList;
    return matchList;
  };
  return [
    filter(([k]) => k == "name"),
    filter(([k]) => k.startsWith("name:")),
    filter(([k]) => k == "namespace"),
    filter(([k]) => k == "version"),
    filter(([k]) => k == "author"),
    filter(([k]) => k == "description"),
    filter(([k]) => k.startsWith("description:")),
    filter(([k]) => k == "license"),
    filter(([k]) => k == "copyright"),
    filter(([k]) => k == "icon"),
    filter(([k]) => k == "iconURL"),
    filter(([k]) => k == "icon64"),
    filter(([k]) => k == "icon64URL"),
    filter(([k]) => k == "defaulticon"),
    filter(([k]) => k == "homepage"),
    filter(([k]) => k == "homepageURL"),
    filter(([k]) => k == "website"),
    filter(([k]) => k == "source"),
    filter(([k]) => k == "supportURL"),
    filter(([k]) => k == "downloadURL"),
    filter(([k]) => k == "updateURL"),
    filter(([k]) => k == "include"),
    filter(([k]) => k == "match"),
    filter(([k]) => k == "exclude"),
    filter(([k]) => k == "exclude-match"),
    filter(([k]) => k == "webRequest"),
    filter(([k]) => k == "require"),
    filter(([k]) => k == "resource").sort(stringSort),
    filter(([k]) => k == "sandbox"),
    filter(([k]) => k == "connect"),
    filter(([k]) => k == "grant").sort(stringSort),
    filter(([k]) => k == "inject-into"),
    filter(([k]) => k == "run-at"),
    filter(([k]) => k == "compatible"),
    filter(([k]) => k == "incompatible"),
    filter(([k]) => k == "antifeature").sort(stringSort),
    filter(([k]) => k.startsWith("antifeature:")).sort(stringSort),
    filter(([k]) => k == "contributionAmount"),
    filter(([k]) => k == "contributionURL"),
    filter(([k]) => k == "noframes"),
    filter(([k]) => k == "unwrap"),
    p0
  ].flat(1);
};

// src/node/plugins/server.ts
var installUserPath = "/__vite-plugin-monkey.install.user.js";
var gmApiPath = "/__vite-plugin-monkey.gm.api.js";
var entryPath = "/__vite-plugin-monkey.entry.js";
var pullPath = "/__vite-plugin-monkey.pull.js";
var restartStoreKey = "__vite_plugin_monkey_install_url";
var serverPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:server",
    apply: "serve",
    async config(userConfig) {
      var _a, _b, _c;
      return {
        preview: {
          host: ((_a = userConfig.preview) == null ? void 0 : _a.host) ?? "127.0.0.1",
          cors: true
        },
        server: {
          host: ((_b = userConfig.server) == null ? void 0 : _b.host) ?? "127.0.0.1",
          open: ((_c = userConfig.server) == null ? void 0 : _c.open) ?? finalOption.server.open,
          cors: true
        }
      };
    },
    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
    },
    async configureServer(server) {
      for (const [k, v] of Object.entries(finalOption.userscript.name)) {
        Reflect.set(
          finalOption.userscript.name,
          k,
          finalOption.server.prefix(v)
        );
      }
      finalOption.userscript.grant.add("*");
      server.middlewares.use(async (req, res, next) => {
        var _a;
        const reqUrl = req.url;
        if (reqUrl && [installUserPath, entryPath, pullPath, gmApiPath].some(
          (u) => reqUrl.startsWith(u)
        )) {
          Object.entries({
            "access-control-allow-origin": "*",
            "content-type": "application/javascript"
          }).forEach(([k, v]) => {
            res.setHeader(k, v);
          });
          const usp = new URLSearchParams(reqUrl.split("?", 2)[1]);
          if (reqUrl.startsWith(installUserPath)) {
            let origin = (_a = toValidURL(usp.get(`origin`))) == null ? void 0 : _a.origin;
            if (!origin) {
              let { https, host, port } = viteConfig.server;
              if (host == "0.0.0.0") {
                host = "127.0.0.1";
              }
              origin = `${https ? "https" : "http"}://${host}:${port}`;
              logger.warn(
                `can not get origin from install url query parameter, use ${origin}`,
                {
                  time: true
                }
              );
            }
            Reflect.set(globalThis, restartStoreKey, origin);
            const u = new URL(entryPath, origin);
            res.end(
              [
                await finalMonkeyOptionToComment(
                  finalOption,
                  /* @__PURE__ */ new Set(),
                  "serve"
                ),
                fn2string(serverInjectFn, {
                  entrySrc: u.href
                }),
                ""
              ].join("\n\n")
            );
          } else if (reqUrl.startsWith(entryPath)) {
            const htmlText2 = await server.transformIndexHtml(
              "/",
              `<html><head></head></html>`,
              req.originalUrl
            );
            const doc = (0, import_htmlparser2.parseDocument)(htmlText2);
            const scriptList = import_htmlparser2.DomUtils.getElementsByTagType(
              import_htmlparser2.ElementType.Script,
              doc
            );
            const entryList = finalOption.server.mountGmApi ? [gmApiPath] : [];
            scriptList.forEach((p) => {
              const src = p.attribs.src ?? "";
              const textNode = p.firstChild;
              let text = "";
              if ((textNode == null ? void 0 : textNode.type) == import_htmlparser2.ElementType.Text) {
                text = textNode.data ?? "";
              }
              if (src) {
                entryList.push(src);
              } else {
                const usp2 = new URLSearchParams({
                  text: Buffer.from(text, "utf-8").toString("base64url")
                });
                entryList.push(pullPath + `?` + usp2.toString());
              }
            });
            let realEntry = finalOption.entry;
            if (import_node_path3.default.isAbsolute(realEntry)) {
              realEntry = (0, import_vite2.normalizePath)(
                import_node_path3.default.relative(viteConfig.root, realEntry)
              );
            }
            const entryUrl = new URL(realEntry, "http://127.0.0.1");
            entryList.push(entryUrl.pathname + entryUrl.search);
            res.end(
              entryList.map((s) => `import ${JSON.stringify(s)};`).join("\n")
            );
          } else if (reqUrl.startsWith(pullPath)) {
            res.end(
              Buffer.from(usp.get("text") ?? "", "base64url").toString("utf-8")
            );
          } else if (reqUrl.startsWith(gmApiPath)) {
            if (finalOption.server.mountGmApi) {
              res.end(`;(${mountGmApiFn})(import.meta);`);
            } else {
              res.end("");
            }
          }
          return;
        }
        next();
      });
      if (finalOption.server.open) {
        const cacheUserPath = `node_modules/.vite/__vite-plugin-monkey.cache.${cyrb53hash(
          viteConfig.configFile
        )}.user.js`;
        let cacheComment = "";
        if (await existFile(cacheUserPath)) {
          cacheComment = (await import_promises2.default.readFile(cacheUserPath)).toString("utf-8");
        } else {
          await import_promises2.default.mkdir(import_node_path3.default.dirname(cacheUserPath)).catch(() => {
          });
        }
        const newComment = await finalMonkeyOptionToComment(
          finalOption,
          /* @__PURE__ */ new Set(),
          "serve"
        );
        const installUrl = Reflect.get(globalThis, restartStoreKey);
        if (!isFirstBoot() && cacheComment != newComment && installUrl) {
          openBrowser(installUrl, true, logger);
          logger.info("reopen, config comment has changed", { time: true });
        }
        await import_promises2.default.writeFile(cacheUserPath, newComment).catch(() => {
        });
      }
    }
  };
};

// src/node/plugins/virtualHtml.ts
var virtualHtmlPlugin = (finalOption) => {
  return {
    name: "monkey:virtualHtml",
    apply: "serve",
    configureServer(server) {
      server.middlewares.use(async (req, res, next) => {
        const url = req.url || "/";
        if (["/", "/index.html"].includes(url)) {
          res.setHeader("content-type", "text/html");
          res.setHeader("cache-control", "no-cache");
          res.setHeader("access-control-allow-origin", "*");
          return res.end(fcToHtml(virtualHtmlTemplate, installUserPath));
        }
        next();
      });
    }
  };
};

// src/node/plugins/fixViteAsset.ts
var template = `
export default ((()=>{
  try{
    return new URL(__VALUE__, import.meta['url']).href
  }catch(_){
    return __VALUE__
  }
})())
`.trimStart();
var fixViteAssetPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:fixViteAsset",
    apply: "serve",
    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
    },
    async transform(code, id) {
      var _a;
      const [_, query = "url"] = id.split("?", 2);
      if ((query.split("&").includes("url") || viteConfig.assetsInclude(id)) && code.match(/^\s*export\s+default/)) {
        const ast = this.parse(code);
        if (ast.type == "Program") {
          const defaultNode = (_a = ast.body) == null ? void 0 : _a[0];
          if ((defaultNode == null ? void 0 : defaultNode.type) == "ExportDefaultDeclaration") {
            const declarationNode = defaultNode == null ? void 0 : defaultNode.declaration;
            const value = declarationNode == null ? void 0 : declarationNode.value;
            if ((declarationNode == null ? void 0 : declarationNode.type) == "Literal" && typeof value == "string") {
              return template.replace(/__VALUE__/g, JSON.stringify(value));
            }
          }
        }
      }
    }
  };
};

// src/node/plugins/fixViteClient.ts
var fixViteClientPlugin = (finalOption) => {
  return {
    name: "monkey:fixViteClient",
    apply: "serve",
    async transform(code, id) {
      if (id.endsWith("node_modules/vite/dist/client/client.mjs")) {
        code = code.replace(
          /__HMR_PROTOCOL__/g,
          `(__HMR_PROTOCOL__ || ((()=>{const u = new URL(import.meta['url'], location.origin);return u.protocol === 'https:' ? 'wss' : 'ws'})()))`
        );
        code = code.replace(
          /__BASE__/g,
          `((()=>{const b = __BASE__; const u = new URL(import.meta['url'], location.origin); return b !== '/' ? b : (u.origin+'/');})())`
        );
        code = code.replace(
          "`${location.protocol}//${hostAndPath}`",
          "`${new URL(import.meta['url'], location.origin).protocol}//${hostAndPath}`"
        );
        return code;
      }
    }
  };
};

// src/node/plugins/externalGlobals.ts
var import_vite3 = require("vite");
var externalGlobalsPlugin = (finalOption) => {
  const { globalsPkg2VarName, requirePkgList } = finalOption;
  return {
    name: "monkey:externalGlobals",
    enforce: "pre",
    apply: "build",
    async config() {
      for (const [moduleName, varName2LibUrl] of finalOption.build.externalGlobals) {
        const { name, version } = await getModuleRealInfo(moduleName);
        if (typeof varName2LibUrl == "string") {
          globalsPkg2VarName[moduleName] = varName2LibUrl;
        } else if (typeof varName2LibUrl == "function") {
          globalsPkg2VarName[moduleName] = await varName2LibUrl(
            version,
            name,
            moduleName
          );
        } else if (varName2LibUrl instanceof Array) {
          const [varName, ...libUrlList] = varName2LibUrl;
          if (typeof varName == "string") {
            globalsPkg2VarName[moduleName] = varName;
          } else if (typeof varName == "function") {
            globalsPkg2VarName[moduleName] = await varName(
              version,
              name,
              moduleName
            );
          }
          for (const libUrl of libUrlList) {
            if (typeof libUrl == "string") {
              requirePkgList.push({ url: libUrl, moduleName });
            } else if (typeof libUrl == "function") {
              requirePkgList.push({
                url: await libUrl(version, name, moduleName),
                moduleName
              });
            }
          }
        }
      }
      return {
        build: {
          rollupOptions: {
            external(source, _importer, _isResolved) {
              return source in globalsPkg2VarName;
            }
            // output: {
            //   globals: globalsPkg2VarName,
            //   inlineDynamicImports: true, // see https://rollupjs.org/guide/en/#outputinlinedynamicimports
            // },
          }
        }
      };
    },
    // async resolveDynamicImport(specifier, _importer) {
    //   if (typeof specifier == 'string' && specifier in globalsPkg2VarName) {
    //     return dynamicImportPrefix + specifier + '\0';
    //   }
    // },
    // async load(id) {
    //   if (id.startsWith(dynamicImportPrefix) && id.endsWith('\0')) {
    //     const rawId = id.slice(dynamicImportPrefix.length, id.length - 1);
    //     if (rawId in globalsPkg2VarName) {
    //       return `export {default} from '${rawId}';export * from '${rawId}';`;
    //     }
    //   }
    // },
    async generateBundle() {
      const usedModIdSet = new Set(
        Array.from(this.getModuleIds()).map((s) => (0, import_vite3.normalizePath)(s))
      );
      finalOption.collectRequireUrls = requirePkgList.filter((p) => usedModIdSet.has(p.moduleName)).map((p) => p.url);
    }
  };
};

// src/node/plugins/externalLoader.ts
var import_vite4 = require("vite");
var cssLoader = (resourceName) => {
  const css = GM_getResourceText(resourceName);
  GM_addStyle(css);
  return css;
};
var jsonLoader = (resourceName) => (
  // @ts-ignore
  JSON.parse(GM_getResourceText(resourceName))
);
var urlLoader = (resourceName, mediaType) => (
  // @ts-ignore
  GM_getResourceURL(resourceName, false).replace(
    /^data:application;base64,/,
    `data:${mediaType};base64,`
  )
);
var rawLoader = (resourceName) => (
  // @ts-ignore
  GM_getResourceText(resourceName)
);
var moduleSourceCode = [
  `export const cssLoader = ${cssLoader}`,
  `export const jsonLoader = ${jsonLoader}`,
  `export const urlLoader = ${urlLoader}`,
  `export const rawLoader = ${rawLoader}`
].join(";");
var externalLoaderPlugin = (finalOption) => {
  return {
    name: "monkey:externalLoader",
    enforce: "pre",
    apply: "build",
    async resolveId(id) {
      if (id == "virtual:plugin-monkey-loader") {
        return "\0" + id;
      }
    },
    async load(id) {
      if (id == "\0virtual:plugin-monkey-loader") {
        return (0, import_vite4.transformWithEsbuild)(
          moduleSourceCode,
          "/virtual/plugin-monkey-loader/index.js",
          {
            minify: true,
            sourcemap: true,
            legalComments: "none"
          }
        );
      }
    }
  };
};

// src/node/plugins/externalResource.ts
var import_vite5 = require("vite");
var import_mrmime = require("mrmime");
var import_node_url = require("url");
var resourceImportPrefix = "\0monkey-resource-import:";
var externalResourcePlugin = (finalOption) => {
  const resourceRecord = {};
  let viteConfig;
  return {
    name: "monkey:externalResource",
    enforce: "pre",
    apply: "build",
    configResolved(config) {
      viteConfig = config;
    },
    async resolveId(id) {
      const { externalResource } = finalOption.build;
      if (id in externalResource) {
        return resourceImportPrefix + id + "\0";
      }
      const [resource, query] = id.split("?", 2);
      if (resource.endsWith(".css") && query) {
        const id2 = [
          resource,
          "?",
          query.split("&").filter((e) => e != "used").join(`&`)
        ].join("");
        if (id2 in externalResource) {
          return resourceImportPrefix + id2 + "\0";
        }
      }
    },
    async load(id) {
      if (id.startsWith(resourceImportPrefix) && id.endsWith("\0")) {
        const { externalResource } = finalOption.build;
        const importName = id.substring(
          resourceImportPrefix.length,
          id.length - 1
        );
        if (!(importName in externalResource)) {
          return;
        }
        const pkg = await getModuleRealInfo(importName);
        const {
          resourceName: resourceNameFn,
          resourceUrl: resourceUrlFn,
          loader,
          nodeLoader
        } = externalResource[importName];
        const resourceName = await resourceNameFn({ ...pkg, importName });
        const resourceUrl = await resourceUrlFn({ ...pkg, importName });
        resourceRecord[importName] = {
          resourceName,
          resourceUrl
        };
        if (nodeLoader) {
          return miniCode(
            await nodeLoader({
              ...pkg,
              resourceName,
              resourceUrl,
              importName
            })
          );
        } else if (loader) {
          let fnText;
          if (loader.prototype && // not arrow function
          loader.name.length > 0 && loader.name != "function") {
            if (Reflect.get(loader, Symbol.toStringTag) == "AsyncFunction") {
              fnText = loader.toString().replace(/^[\s\S]+?\(/, "async function(");
            } else {
              fnText = loader.toString().replace(/^[\s\S]+?\(/, "function(");
            }
          } else {
            fnText = loader.toString();
          }
          return miniCode(
            `export default (${fnText})(${JSON.stringify({
              resourceUrl,
              importName,
              ...pkg
            })})`
          );
        }
        let moduleCode = void 0;
        const [resource, query] = importName.split("?", 2);
        const ext = resource.split(".").pop();
        const mimeType = (0, import_mrmime.lookup)(ext) ?? "application/octet-stream";
        const suffixSet = new import_node_url.URLSearchParams(query);
        if (suffixSet.has("url") || suffixSet.has("inline")) {
          moduleCode = [
            `import {urlLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([
              resourceName,
              mimeType
            ])})`
          ].join(";");
        } else if (suffixSet.has("raw")) {
          moduleCode = [
            `import {rawLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([resourceName])})`
          ].join(";");
        } else if (ext == "json") {
          moduleCode = [
            `import {jsonLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([resourceName])})`
          ].join(";");
        } else if (ext == "css") {
          moduleCode = [
            `import {cssLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([resourceName])})`
          ].join(";");
        } else if (viteConfig.assetsInclude(importName.split("?", 1)[0])) {
          const mediaType = import_mrmime.mimes[ext];
          moduleCode = [
            `import {urlLoader as loader} from 'virtual:plugin-monkey-loader'`,
            `export default loader(...${JSON.stringify([
              resourceName,
              mediaType
            ])})`
          ].join(";");
        }
        if (moduleCode) {
          if (moduleCode.includes("rawLoader") || moduleCode.includes("jsonLoader") || moduleCode.includes("cssLoader")) {
            finalOption.userscript.grant.add("GM_getResourceText");
          } else if (moduleCode.includes("urlLoader")) {
            finalOption.userscript.grant.add("GM_getResourceURL");
          }
          return miniCode(moduleCode);
        }
        throw new Error(`module: ${importName} not found loader`);
      }
    },
    generateBundle() {
      const usedModIdSet = new Set(
        Array.from(this.getModuleIds()).map((s) => (0, import_vite5.normalizePath)(s))
      );
      Array.from(usedModIdSet).forEach((id) => {
        if (id.startsWith(resourceImportPrefix) && id.endsWith("\0")) {
          usedModIdSet.add(
            id.substring(resourceImportPrefix.length, id.length - 1)
          );
        }
      });
      const collectResource = {};
      Object.entries(resourceRecord).forEach(
        ([importName, { resourceName, resourceUrl }]) => {
          if (usedModIdSet.has(importName)) {
            collectResource[resourceName] = resourceUrl;
          }
        }
      );
      finalOption.collectResource = collectResource;
    }
  };
};

// src/node/plugins/finalBundle.ts
var import_vite7 = require("vite");

// src/node/_lazy.ts
var lazyValuePlaceholder = {};
var lazyValue = (fn) => {
  let temp = lazyValuePlaceholder;
  return {
    get value() {
      if (temp === lazyValuePlaceholder) {
        temp = fn();
      }
      return temp;
    }
  };
};

// src/node/systemjs.ts
var import_node_module2 = __toESM(require("module"), 1);
var import_promises3 = __toESM(require("fs/promises"), 1);

// src/node/util.ts
var util_exports = {};
__export(util_exports, {
  dataUrl: () => dataUrl,
  fn2dataUrl: () => fn2dataUrl,
  unimportPreset: () => unimportPreset
});
var import_vite6 = require("vite");
var fn2dataUrl = async (fn, ...args) => {
  return "data:application/javascript," + encodeURIComponent(
    (await (0, import_vite6.transformWithEsbuild)(
      `;(${fn})(...${JSON.stringify(args)})`,
      "any_name.js",
      {
        minify: true,
        sourcemap: false,
        legalComments: "none"
      }
    )).code.trimEnd()
  );
};
function dataUrl(p0, ...args) {
  if (typeof p0 == "string") {
    return `data:application/javascript,` + encodeURIComponent(p0);
  }
  return fn2dataUrl(p0, ...args);
}
var unimportPreset = {
  from: "vite-plugin-monkey/dist/client",
  imports: [
    "GM",
    "GM_addElement",
    "GM_addStyle",
    "GM_addValueChangeListener",
    "GM_cookie",
    "GM_deleteValue",
    "GM_download",
    "GM_getResourceText",
    "GM_getResourceURL",
    "GM_getTab",
    "GM_getTabs",
    "GM_getValue",
    "GM_info",
    "GM_listValues",
    "GM_log",
    "GM_notification",
    "GM_openInTab",
    "GM_registerMenuCommand",
    "GM_removeValueChangeListener",
    "GM_saveTab",
    "GM_setClipboard",
    "GM_setValue",
    "GM_unregisterMenuCommand",
    "GM_xmlhttpRequest",
    "GM_webRequest",
    "unsafeWindow",
    "monkeyWindow"
  ]
};

// src/node/systemjs.ts
var _require = import_node_module2.default.createRequire(importMetaUrl);
var systemjsPkg = _require(`systemjs/package.json`);
var systemjsSubPaths = [
  "dist/system.min.js",
  "dist/extras/named-register.min.js"
];
var customSystemInstanceCode = `;(typeof System!='undefined')&&(System=new System.constructor());`;
var systemjsAbsolutePaths = systemjsSubPaths.map((s) => {
  return _require.resolve(`systemjs/` + s);
});
var systemjsTexts = lazyValue(() => {
  return Promise.all(
    systemjsAbsolutePaths.map(
      (s) => import_promises3.default.readFile(s, "utf-8").then(
        (s2) => s2.trim().replace(/^\/\*[\s\S]*?\*\//, "").replace(/\/\/.*map$/, "").trim()
      )
    ).concat([Promise.resolve(customSystemInstanceCode)])
  );
});
var getSystemjsRequireUrls = (fn) => {
  return systemjsSubPaths.map((p) => {
    return fn(systemjsPkg.version, systemjsPkg.name, p, p);
  }).concat([dataUrl(customSystemInstanceCode)]);
};

// src/node/topLevelAwait.ts
var acornWalk2 = __toESM(require("acorn-walk"), 1);
var import_magic_string = __toESM(require("magic-string"), 1);
var awaitOffset = `await`.length;
var initTlaIdentifier = `_TLA_`;
var findSafeTlaIdentifier = (rawBundle) => {
  const codes = [];
  for (const chunk of Object.values(rawBundle)) {
    if (chunk.type == "chunk") {
      codes.push(chunk.code);
    }
  }
  let x = 0;
  let identifier = initTlaIdentifier;
  while (codes.some((code) => code.includes(identifier))) {
    x++;
    identifier = initTlaIdentifier + x.toString(36);
  }
  return identifier;
};
var startWith = (text, searchString, position = 0, ignoreString) => {
  for (let i = position; i < text.length; i++) {
    if (ignoreString.includes(text[i])) {
      continue;
    }
    return text.startsWith(searchString, i);
  }
  return false;
};
var transformTlaToIdentifier = (context, chunk, identifier) => {
  if (chunk.type == "chunk") {
    const code = chunk.code;
    if (!code.includes(`await`)) {
      return;
    }
    const ast = context.parse(code);
    const tlaNodes = [];
    const tlaForOfNodes = [];
    acornWalk2.simple(
      ast,
      {
        AwaitExpression(node) {
          tlaNodes.push(node);
        },
        // @ts-ignore
        ForOfStatement(node) {
          if (node.await === true) {
            tlaForOfNodes.push(node);
          }
        }
      },
      { ...acornWalk2.base, Function: () => {
      } }
    );
    if (tlaNodes.length > 0 || tlaForOfNodes.length > 0) {
      const ms = new import_magic_string.default(code);
      tlaNodes.forEach((node) => {
        if (!startWith(chunk.code, "(", node.start + awaitOffset, " 	\r\n")) {
          ms.appendLeft(node.start + awaitOffset, `(`);
          ms.appendRight(node.end, `)`);
        }
        ms.update(node.start, node.start + awaitOffset, identifier);
      });
      tlaForOfNodes.forEach((node) => {
        ms.appendLeft(node.start, `${identifier + `FOR`}((async()=>{`);
        ms.appendRight(node.end, `})());`);
      });
      return {
        code: ms.toString(),
        map: ms.generateMap()
      };
    }
  }
};
var transformIdentifierToTla = (context, chunk, identifier) => {
  if (chunk.type == "chunk") {
    if (!chunk.code.includes(identifier)) {
      return;
    }
    const base3 = Object.keys(acornWalk2.base).reduce((p, key) => {
      if (key in p)
        return p;
      p[key] = (node, state, callback) => {
        if (chunk.code.substring(node.start, node.end).includes(identifier)) {
          return acornWalk2.base[key](node, state, callback);
        }
      };
      return p;
    }, {});
    const ast = context.parse(chunk.code);
    const tlaCallNodes = [];
    const forTlaCallNodes = [];
    const topFnNodes = [];
    acornWalk2.simple(
      ast,
      {
        // @ts-ignore
        CallExpression(node) {
          const { name, type } = node.callee ?? {};
          if (type === `Identifier`) {
            if (name === identifier) {
              tlaCallNodes.push(node);
            } else if (name === identifier + `FOR`) {
              forTlaCallNodes.push(node);
            }
          }
        }
      },
      {
        ...base3,
        Function: (node, state, callback) => {
          if (topFnNodes.length == 0) {
            topFnNodes.push(node);
          }
          if (chunk.code.substring(node.start, node.end).includes(identifier)) {
            return acornWalk2.base.Function(node, state, callback);
          }
        }
      }
    );
    if (tlaCallNodes.length > 0 || forTlaCallNodes.length > 0) {
      const ms = new import_magic_string.default(chunk.code, {});
      tlaCallNodes.forEach((node) => {
        const callee = node.callee;
        ms.update(callee.start, callee.end, "await");
      });
      forTlaCallNodes.forEach((node) => {
        var _a, _b, _c, _d, _e;
        const forOfNode = (_e = (_d = (_c = (_b = (_a = node.arguments) == null ? void 0 : _a[0]) == null ? void 0 : _b.callee) == null ? void 0 : _c.body) == null ? void 0 : _d.body) == null ? void 0 : _e[0];
        ms.update(node.start, forOfNode.start, "");
        ms.update(forOfNode.end, node.end, "");
      });
      topFnNodes.forEach((node) => {
        ms.appendLeft(node.start, `async `);
      });
      chunk.code = ms.toString();
      if (chunk.map) {
        chunk.map;
      }
    }
  }
};

// src/node/plugins/finalBundle.ts
var __entry_name = `__monkey.entry.js`;
var polyfillId = "\0vite/legacy-polyfills";
var systemJsImportMapPrefix = `user`;
var finalBundlePlugin = (finalOption) => {
  return {
    name: "monkey:finalBundle",
    apply: "build",
    enforce: "post",
    async generateBundle(_, rawBundle) {
      const entryChunks = [];
      const chunks = [];
      Object.values(rawBundle).forEach((chunk) => {
        if (chunk.type == "chunk") {
          if (chunk.facadeModuleId != polyfillId) {
            chunks.push(chunk);
          }
          if (chunk.isEntry) {
            if (chunk.facadeModuleId == polyfillId) {
              entryChunks.unshift(chunk);
            } else {
              entryChunks.push(chunk);
            }
          }
        }
      });
      const fristEntryChunk = entryChunks.find(
        (s) => s.facadeModuleId != polyfillId
      );
      const hasDynamicImport = entryChunks.some(
        (e) => e.dynamicImports.length > 0
      );
      const usedModules = /* @__PURE__ */ new Set();
      const tlaIdentifier = lazyValue(() => findSafeTlaIdentifier(rawBundle));
      const buildResult = await (0, import_vite7.build)({
        logLevel: "error",
        configFile: false,
        esbuild: false,
        plugins: [
          {
            name: "mokey:mock",
            enforce: "pre",
            resolveId(source, importer, options) {
              if (!importer && options.isEntry) {
                return "\0" + source;
              }
              const chunk = Object.values(rawBundle).find(
                (chunk2) => chunk2.type == "chunk" && source.endsWith(chunk2.fileName)
              );
              if (chunk) {
                return "\0" + source;
              }
            },
            async load(id) {
              if (!id.startsWith("\0"))
                return;
              if (id.endsWith(__entry_name)) {
                return entryChunks.map((a) => `import ${JSON.stringify(`./${a.fileName}`)};`).join("\n");
              }
              const [k, chunk] = Object.entries(rawBundle).find(
                ([k2, chunk2]) => id.endsWith(chunk2.fileName)
              ) ?? [];
              if (chunk && chunk.type == "chunk" && k) {
                usedModules.add(k);
                if (!hasDynamicImport) {
                  const ch = transformTlaToIdentifier(
                    this,
                    chunk,
                    tlaIdentifier.value
                  );
                  if (ch)
                    return ch;
                }
                return {
                  code: chunk.code,
                  map: chunk.map
                };
              }
            },
            generateBundle(_2, iifeBundle) {
              if (hasDynamicImport) {
                return;
              }
              Object.entries(iifeBundle).forEach(([k, chunk]) => {
                transformIdentifierToTla(this, chunk, tlaIdentifier.value);
              });
            }
          }
        ],
        build: {
          write: false,
          minify: false,
          target: "esnext",
          rollupOptions: {
            external(source) {
              return source in finalOption.globalsPkg2VarName;
            },
            output: {
              globals: finalOption.globalsPkg2VarName
            }
          },
          lib: {
            entry: __entry_name,
            formats: [hasDynamicImport ? "system" : "iife"],
            name: hasDynamicImport ? void 0 : "__expose__",
            fileName: () => `__entry.js`
          }
        }
      });
      usedModules.forEach((k) => {
        if (fristEntryChunk != rawBundle[k]) {
          delete rawBundle[k];
        }
      });
      const buildBundle = buildResult[0].output.flat();
      let finalJsCode = ``;
      if (hasDynamicImport) {
        const systemJsModules = [];
        let entryName = "";
        Object.entries(buildBundle).forEach(([k, chunk]) => {
          if (chunk.type == "chunk") {
            const name = JSON.stringify(`./` + chunk.fileName);
            systemJsModules.push(
              chunk.code.trimStart().replace(/^System\.register\(/, `System.register(${name}, `)
            );
            if (chunk.isEntry) {
              entryName = name;
            }
          }
        });
        systemJsModules.push(`System.import(${entryName}, "./");`);
        finalJsCode = systemJsModules.join("\n");
        const usedModuleIds = Array.from(this.getModuleIds()).filter(
          (d) => d in finalOption.globalsPkg2VarName
        );
        const importsMap = usedModuleIds.reduce(
          (p, c) => {
            p[c] = `${systemJsImportMapPrefix}:${c}`;
            return p;
          },
          {}
        );
        finalJsCode = [
          Object.keys(importsMap).length > 0 ? `System.addImportMap({ imports: ${JSON.stringify(importsMap)} });` : ``,
          ...usedModuleIds.map(
            (id) => `System.set(${JSON.stringify(
              `${systemJsImportMapPrefix}:${id}`
            )}, ${moduleExportExpressionWrapper(
              finalOption.globalsPkg2VarName[id]
            )});`
          ),
          "\n" + finalJsCode
        ].filter((s) => s).join("\n");
        if (typeof finalOption.systemjs == "function") {
          finalOption.collectRequireUrls.push(
            ...getSystemjsRequireUrls(finalOption.systemjs)
          );
        } else {
          finalJsCode = (await systemjsTexts.value).join("\n") + "\n" + finalJsCode;
        }
      } else {
        Object.entries(buildBundle).forEach(([k, chunk]) => {
          if (chunk.type == "chunk" && chunk.isEntry) {
            finalJsCode = chunk.code;
          }
        });
      }
      const injectCssCode = await getInjectCssCode(finalOption, rawBundle);
      let collectGrantSet;
      if (finalOption.build.autoGrant) {
        collectGrantSet = collectGrant(
          this,
          chunks.map((s) => s.code).concat(injectCssCode || ``)
        );
      } else {
        collectGrantSet = /* @__PURE__ */ new Set();
      }
      const comment = await finalMonkeyOptionToComment(
        finalOption,
        collectGrantSet,
        "build"
      );
      const mergedCode = [comment, injectCssCode, finalJsCode].filter((s) => s).join(`

`).trimEnd();
      if (fristEntryChunk) {
        fristEntryChunk.fileName = finalOption.build.fileName;
        fristEntryChunk.code = mergedCode;
      } else {
        this.emitFile({
          type: "asset",
          fileName: finalOption.build.fileName,
          source: mergedCode
        });
      }
      if (finalOption.build.metaFileName) {
        this.emitFile({
          type: "asset",
          fileName: finalOption.build.metaFileName(),
          source: await finalMonkeyOptionToComment(
            finalOption,
            collectGrantSet,
            "meta"
          )
        });
      }
    }
  };
};

// src/node/plugins/perview.ts
var import_node_path4 = __toESM(require("path"), 1);
var import_vite8 = require("vite");
var perviewPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:perview",
    apply: "serve",
    configResolved(config) {
      viteConfig = config;
    },
    async configurePreviewServer(server) {
      server.middlewares.use(async (req, res, next) => {
        if (["/", "/index.html"].includes((req.url ?? "").split("?")[0])) {
          const distDirPath = import_node_path4.default.join(process.cwd(), viteConfig.build.outDir);
          const urls = [];
          for await (const pathname of walk(distDirPath)) {
            if (pathname.endsWith(".user.js")) {
              const fileName = (0, import_vite8.normalizePath)(
                import_node_path4.default.relative(distDirPath, pathname)
              );
              urls.push(`/` + fileName);
            }
          }
          res.setHeader("content-type", "text/html; charset=utf-8");
          res.end(fcToHtml(previewTemplate, urls));
          return;
        }
        next();
      });
    }
  };
};

// src/node/plugins/redirectClient.ts
var redirectClientPlugin = (finalOption) => {
  return {
    name: "monkey:redirectClient",
    enforce: "pre",
    apply: "build",
    resolveId(source, importer, options) {
      if (source == "vite-plugin-monkey/dist/client") {
        return this.resolve(
          "vite-plugin-monkey/dist/native",
          importer,
          options
        );
      }
    }
  };
};

// src/node/plugins/inlinesAsset.ts
var import_promises4 = __toESM(require("fs/promises"), 1);
var inlinesAssetPlugin = (finalOption) => {
  let viteConfig;
  return {
    name: "monkey:inlinesAsset",
    enforce: "post",
    apply: "build",
    async configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
    },
    async transform(code, id) {
      if (viteConfig.assetsInclude(id) && [`.svg`, `.svg?inline`, `.svg?url`].some((s) => id.endsWith(s)) && code.includes(`__VITE_ASSET__`)) {
        const base64Text = (await import_promises4.default.readFile(id.split("?")[0])).toString(
          "base64"
        );
        return `export default ${JSON.stringify(
          `data:image/svg+xml;base64,` + base64Text
        )}`;
      }
    },
    generateBundle(opts, bundle) {
      for (const key in bundle) {
        if ([`.svg`].some((s) => key.endsWith(s))) {
          delete bundle[key];
        }
      }
    }
  };
};

// src/node/plugins/index.ts
var monkeyPluginList = [
  // only serve
  virtualHtmlPlugin,
  fixViteAssetPlugin,
  fixViteClientPlugin,
  serverPlugin,
  // only build pre
  redirectClientPlugin,
  externalLoaderPlugin,
  externalResourcePlugin,
  externalGlobalsPlugin,
  // only build post
  inlinesAssetPlugin,
  // only build, final build
  finalBundlePlugin,
  // only preview
  perviewPlugin
];
var plugins_default = monkeyPluginList;

// src/node/index.ts
var node_default = (pluginOption) => {
  const finalPluginOption = resolvedOption(pluginOption);
  const monkeyPlugin = {
    name: "monkey:entry",
    enforce: "post",
    async config(userConfig, { command }) {
      var _a, _b, _c;
      const isServe = command == "serve";
      return {
        resolve: {
          alias: {
            [finalPluginOption.clientAlias]: "vite-plugin-monkey/dist/client"
          }
        },
        define: {
          "process.env.NODE_ENV": ((_a = userConfig.define) == null ? void 0 : _a["process.env.NODE_ENV"]) ?? JSON.stringify(
            userConfig.mode ?? (isServe ? "development" : "production")
          )
        },
        esbuild: {
          supported: {
            "top-level-await": true
          }
        },
        build: {
          assetsInlineLimit: Number.MAX_SAFE_INTEGER,
          chunkSizeWarningLimit: Number.MAX_SAFE_INTEGER,
          modulePreload: false,
          assetsDir: "./",
          cssCodeSplit: false,
          minify: ((_b = userConfig.build) == null ? void 0 : _b.minify) ?? false,
          cssMinify: ((_c = userConfig.build) == null ? void 0 : _c.cssMinify) ?? true,
          rollupOptions: {
            // serve pre-bundling need
            input: finalPluginOption.entry
          },
          sourcemap: false
          // TODO
          // sourcemap: sourcemap,
        }
      };
    }
  };
  return [monkeyPlugin, ...plugins_default.map((m) => m(finalPluginOption))];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cdn,
  util
});
//# sourceMappingURL=index.cjs.map